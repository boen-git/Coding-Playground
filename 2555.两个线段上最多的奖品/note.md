## 二分查找

由于题目给定的数组按照非递减排序, 且数组中第i个元素表示第i个奖品的位置(奖品位置可以重复).
可以选择长度为k的两个线段, 求两个线段可以覆盖奖品的最大数量.

当然根据贪心法则, 肯定是这两个线段尽量不要有重叠部分, 这样才能使得覆盖的奖品尽可能多, 此时, 我们假设第二条线段的右侧刚好覆盖第i个奖品所在的位置, 第二条线段的左侧刚好覆盖第j个奖品的位置, 此时, 第一条线段右断电一定刚好处于第j-1, j-2, ...,0个礼物的位置, 即两条线段不存在重叠部分, 这样才能保证覆盖的奖品尽可能多.

假设我们知道第二条线段覆盖的右断电刚好为prizePositions[i], 此时由于线段长度为k, 此时该线段左断电为prizePositions[i] - k, 由于每个奖品位置坐标已排序, 此时可以通过二分找到最左侧可以覆盖的奖品为prizePositions[j], 此时, 只需要知道位于prizePositions[j]左侧的第一条线段可以覆盖奖品的最大数量, 就可以知道以prizePosition[i]为第二条线段右端点时可以覆盖奖品的最大数量, 依次枚举第二条线段的右端点即可知道全局最优解.


我们用dp[i]表示右端点不超过prizePositions[i], 一条长度为k的线段最多可以覆盖的奖品的最大数量, 可以推导如下:
- 如果不选择位于prizePositions[i]处的奖品, 则dp[i] = dp[i-1];
- 如果选择位于prizePostions[i]处的奖品, 则通过二分查找找到线段最左侧可以覆盖的奖品的位置prizePositions[j], 则此时dp[i] = i-j+1;

bisect.bisect和bisect.bisect_right返回大于 $x$ 的第一个下标(相当于C++中的upper_bound)，bisect.bisect_left返回大于等于 $x$ 的第一个下标 (相当于C++中的lower_bound)。