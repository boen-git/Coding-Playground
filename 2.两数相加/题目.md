给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]

示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]


用迭代法解决.
从左到右依次相加, 逢10进1.

```
>>> print(14%10)
4
>>> print(14//10)
1
```

Optional类型注解在类型检查（例如使用mypy这样的静态类型检查器）时非常有用，因为它可以帮助开发者理解函数应该如何使用，并且能够捕获一些可能的错误，比如将None传递给一个期望非None值的函数。

在Python 3.10及以后的版本中，Optional已经被弃用，推荐直接使用Union类型注解来代替，例如：

```python
from typing import Union

def addTwoNumbers(self, l1: Union[ListNode, None], l2: Union[ListNode, None]) -> Union[ListNode, None]:
```

这里的Union[ListNode, None]与Optional[ListNode]是等价的。




让我们详细解释代码中的这两个关键行：

### `current.next = ListNode(sum % 10)`

这一行的作用是创建一个新的链表节点，并将其添加到结果链表中。具体来说：

1. **计算当前位的值**：
   - `sum % 10` 计算的是当前位的数字。例如，如果当前的 `sum` 是 15，那么 `sum % 10` 就是 5。这里的 `% 10` 运算符用于提取个位数字。

2. **创建新节点**：
   - `ListNode(sum % 10)` 创建一个新的链表节点，其中 `sum % 10` 作为节点的值。例如，如果 `sum % 10` 是 5，则新节点的值是 5。

3. **将新节点连接到结果链表中**：
   - `current.next` 将新的节点链接到当前节点 `current` 的 `next` 属性。这样，新节点就会成为结果链表中的下一个节点。

4. **更新当前节点**：
   - `current = current.next` 将 `current` 更新为刚刚创建的节点，以便下一次循环时能将新节点添加到结果链表中。

### `return dummy.next`

这一行代码的作用是返回结果链表的实际头节点。

1. **`dummy` 节点**：
   - 在创建结果链表时，使用了一个 `dummy` 节点作为链表的虚拟头节点。`dummy` 节点的 `val` 初始值为 0，`next` 初始化为空。这个 `dummy` 节点并不包含实际的数据，它只是一个辅助节点，用于简化链表的操作，特别是在处理链表的头节点时。

2. **返回结果**：
   - `dummy.next` 是结果链表的第一个实际节点。由于 `dummy` 节点本身并不包含实际的数据（它只是为了简化代码逻辑），我们需要返回 `dummy.next` 来获得真正的结果链表的头节点。

总结起来，这两行代码分别负责将计算出的当前位的数字添加到结果链表中，并返回结果链表的实际头节点。这使得整个链表的构造过程能够顺利进行，并最终得到表示两个输入链表数字之和的链表。